
※ 1
JPA(Java Persistence API)  <-  Hibernate  <-  Spring Data JPA

* Hibernate : 인터페이스인 JPA를 사용하기 위한 구현체
* Spring Data JPA를 쓰는 이유
    1. 구현체 교체가 용이함 (Hibernate 외에 다른 구현체로...)
    2.  저장소 교체가 용이함(RDB말고 MongoDB로 연결하고 싶을 때...)





※ 2
Entity 클래스에서는 절대 Setter 메소드를 만들지 않는다. 이유는 해당 클래스의 인스턴스 값들이
언제 어디서 변해야 하는지 코드상으로 명확하게 구분할 수가 없어, 차후 기능 변경 시 정말 복잡해지기
때문이다.

대신, 해당 필드의 값 변경이 필요하면 명확히 그 목적과 의도를 나타낼 수 있는 메소드를 추가해야만 한다.


Setter가 없는 상황에서 어떻게 값을 채워 DB에 삽입을 해야할까?

기본적인 구조는 생성자를 통해 최종값을 채운 후 DB에 삽입하는 것이며, 값 변경이 필요한 경우
해당 이벤트에 맞는 public 메소드를 호출하여 변경하는 것을 전제로 한다.

또 다른 방법으로는 @Builder를 통해 제공되는 빌더 클래스를 사용하는 것이다. 생성자난 빌더나
생성 시점에 값을 채워주는 역할을 똑같다. 다만, 생성자의 경우 지금 채워야할 필드가 무엇인지
명확히 지정할 수가 없다.

ex) 생성자 방식
public Example(String a, String b) {
    this.a = a;
    this.b = b;
}

ex) 빌더 방식
Example.builder()
    .a(a)
    .b(b)
    .build();





※ 3
* Web Layer
    - 흔히 사용되는 컨트롤러(@Controller)와 JSP/Freemarker 등의 뷰 템플릿 영역
    - 이외에도 필터(@Filter), 인터셉터, 컨트롤러 어드바이스(@ControllerAdvice) 등
      외부 요청과 응답에 대한 전반적인 영역을 이야기한다.

* Service Layer
    - @Service에 사용되는 서비스 영역
    - 일반적으로 Controller와 Dao의 중간 영역에서 사용된다.
    - @Transactional이 사용되어야 하는 영역이기도 하다.

* Repository Layer
    - Database와 같이 데이터 저장소에 접근하는 영역
    - 기존의 Dao(Data Access Object)영역으로 이해하면 됨.

* Dtos
    - Dto(Data Transfer Object)는 계층 간에 데이터 교환을 위한 객체를 이야기하며
      Dtos는 이들의 영역을 얘기한다.
    - 예를 들어, 뷰 템플릿 엔진에서 사용될 객체나 Repository Layer에서 결과로 넘겨준
      객체 등을 말한다.
    - Entity 클래스와 거의 유사한 형태이지만, Entity 클래스는 Request/Response 클래스로
      사용해서는 안 된다.

* Domain Model
    - 도메인이라 불리는 개발 대상을 모든 사람이 동일한 관점에서 이해할 수 있고 공유할 수 있도록
      단순화시킨 것을 도메인 모델이라고 한다.
    - @Entity가 사용된 영역 역시 도메인 모델이라고 할 수 있다.
    - 다만, 무조건 데이터베이스의 테이블과 관계가 있어야만 하는 것은 아니다.
    - VO처럼 값 객체들도 이 영역에 해당하기 때문이다.

ps. 위의 5가지 계층에서 비즈니스 처리를 담당하는 곳은 Domain이다.
    기존에 서비스로 처리하던 방식을 '트랜잭션 스크립트'라고 한다.
    서비스는 트랜잭션과 도메인 간의 순서만 보장해준다.





※ 4
스프링에서 Bean 주입 방식에는 3가지가 있다.
* @Autowired
* setter
* 생성자

이 중에서 '생성자로 주입받는 방식'을 가장 권장한다.
@RequiredArgsConstructor는 final로 선언된 모든 필드를 인자값으로 하는 생성자를
롬복의 @RequiredArgsConstructor가 대신 생성해준 것.

@RequiredArgsConstructor를 사용하면 해당 클래스의 의존성 관계가 변경될 때마다
생성자 코드를 계속해서 수정하는 번거로움을 해결할 수 있다.





※ 5
* Dto와 Entity 클래스를 분리하는 이유
Entity 클래스는 데이터베이스와 맞닿은 핵심 클래스이다.
Entity 클래스를 기준으로 테이블이 생성되고, 스키마가 변경된다.
화면 변경은 아주 사소한 기능 변경인데, 이를 위해 테이블과 연결된 Entity 클래스를 변경하는 것은 너무 큰 변경이다.
또한, 수많은 서비스 클래스나 비즈니스 로직들이 Entity 클래스를 기준으로 동작한다.
Dto(Request/Response)는 View를 위한 클래스라 정말 자주 변경이 필요하다.

따라서, Entity 클래스와 Controller에서 쓸 Dto는 분리해서 사용해야 한다.





※ 6
PostsService의 update 기능 코드를 살펴보면 DB에 쿼리 날리는 부분이 없음을 알 수 있다.
이게 가능한 이유는 JPA의 '영속성 컨텍스트' 때문이다.

영속성 컨텍스트란, 엔티티를 영구 저장하는 환경이다. 일종의 논리적인 개념이라고 보면 되며
JPA의 핵심 내용은 엔티티가 영속성 컨텍스트에 포함되어 있냐 아니냐로 갈린다.

JPA의 엔티티 매니저가 활성화된 상태(Spring Data Jpa의 기본값)로 트랜잭션 안에서 DB에서 데이터를 가져오면
이 데이터는 영속성 컨텍스트가 유지된 상태이다. 이 상태에서 해당 데이터의 값을 변경하면 트랜잭션이 끝나는
시점에 해당 테이블에 변경분을 반영한다. 즉, Entity 객체의 값만 변경하면 별도로 Update 쿼리를 날릴 필요가
없다는 것이다. 이 개념을 '더티 체킹'이라고 한다.





※ 7
* JPA Auditing을 이용한 등록/수정 시간 자동화
보통 엔티티에는 해당 데이터의 생성시간과 수정시간을 포함한다. 이는 추후 유지보수에 있어서 중요한 정보이다.
그렇기 때문에 DB에 삽입, 갱신 코드가 반복되고 모든 테이블과 서비스 메소드에 포함되면서 코드가 지저분해진다.
이러한 문제를 해결하기 위해 'JPA Auditing'을 사용한다.

* LocalDate 사용
Java8부터 LocalDate와 LocalDateTime이 등장했고, 이는 Java의 기본 날짜 타입인 Date의 문제점을 고친 타입이다.

Java8 이전 Date/Calendar 클래스의 문제점
- 불변 객체가 아니다. 이는 멀티스레드 환경에서 언제든 문제가 발생할 수 있다.
- Calendar는 월(Month)값 설계가 잘못되었다. (10월: Calendar.OCTOBER의 숫자 값은 '10'이 아닌 '9'이다)





※ 8
* 템플릿 엔진
지정된 템플릿 양식과 데이터가 합쳐져 HTML 문서를 출력하는 소프트웨어
Spring이나 서블릿 같은 경우 JSP/Freemarker 등, 그리고 Reack, Vue 등이
지정된 템플릿과 데이터를 이용하여 HTML을 생성하는 템플릿 엔진이다.

JSP 등과 같은 전자의 경우는 '서버 템플릿 엔진'이라 부르며,
React와 같은 후자의 경우는 '클라이언트 템플릿 엔진'이라 부른다.

서버 템플릿 엔진을 이용한 화면 생성은 서버에서 Java코드로 문자열을 만든 뒤 이 문자열을 HTML로 변환하여 브라우저로 전달한다.
반면에, 자바스크립트는 브라우저 위에서 작동한다.

React.js나 Vue.js를 이용한 SPA(Single Page Application)는 브라우저에서 화면을 생성한다.
즉, 서버에서 이미 코드가 벗어난 경우이다.





※ 9
* Mustache
머스테치(Mustache)는 JSP와 같이 HTML을 만들어주는 템플릿 엔진이다.

* 템플릿 엔진들의 장단점
[JSP, Velocity]
- 스프링 부트에서는 권장하지 않는 템플릿 엔진.

[Freemarker]
- 템플릿 엔진으로는 너무 과하게 많은 기능들.
- 높은 자유도로 인해 숙련도가 낮을수록 Freemarker 안에 비즈니스 로직이 추가될 확률이 높음.

[Thymeleaf]
- 스프링 진영에서 적극적으로 밀고 있지만 문법이 어려움.
- HTML 태그에 속성으로 템플릿 기능을 사용하는 방식에 진입장벽이 높게 느껴짐.
- Vue.js 사용 경험이 있어 태그 속성 방식이 익숙하다면 선택해도 됨.

[Mustache]
- 문법이 다른 템플릿 엔진보다 심플함.
- 로직 코드를 사용할 수 없어 View의 역할과 서버의 역할이 명확하게 분리됨.
- Mustache.js와 Mustache.java 두 가지가 다 있어, 하나의 문법으로 클라이언트/서버 템플릿을 모두 사용 가능.





※ 10
* 스프링 시큐리티는 막강한 '인증(Authentication)'과 '인가(Authorization)' 기능을 가진 프레임워크다.
만약 로그인을 직접 구현한다면 다음을 전부 구현해야 한다.
- 로그인 시 보안
- 비밀번호 찾기
- 비밀번호 변경
- 회원정보 변경
- 회원가입 시 이메일 혹은 전화번호 인증

OAuth 로그인 구현 시 앞선 목록의 것들을 모두 구글, 네이버 등에 맡기면 되기 때문에,
서비스 개발에 집중할 수 있다.

